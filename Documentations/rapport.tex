%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%     STYLE POUR LES EXPOSES TECHNIQUES 
%         3e année INSA de Rennes
%
%             NE PAS MODIFIER
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\documentclass[a4paper,11pt]{article}

\usepackage{exptech}       % Fichier (./exptech.sty) contenant les styles pour 
                           % l'expose technique (ne pas le modifier)

%\linespread{1,6}          % Pour une version destinée à un relecteur,
                           % décommenter cette commande (double interligne) 
                           
% UTILISEZ SPELL (correcteur orthographique) à accès simplifié depuis XEmacs

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\title{ \textbf{Distributed Chess Service} }
\markright{Distributed Chess Service} 
                           % Pour avoir le titre de l'expose sur chaque page

\author{Paul \textsc{Chaignon}, Thomas \textsc{François}, \\
        Damien \textsc{Le Guen}, Clément \textsc{Gautrais}, \\
				Benoit \textsc{Travers} \\
        \\
        Encadreur : Yann \textsc{Ricquebourg}}

\date{}                    % Ne pas modifier
 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}          

\maketitle                 % Génère le titre
\thispagestyle{empty}      % Supprime le numéro de page sur la 1re page



\begin{abstract}


Le résumé est limité à 10 lignes au maximum.
\end{abstract} 


\section{Introduction}  

[TODO: Attentes de Loic Helouet.]
[TODO: Présenter REST]
[TODO: Spécifications en boîte noire.]


\section{Architecture}

\subsection{Présentation générale}
[TODO: Présenter le fonctionnement général du système.]
\FigureEPS{h,t,b,p}{12cm}{./ArchitectureSimple.eps}
{Schéma général du système}   
{fig:schema-systeme}

\subsection{Interfaces intermédiaires pour les ressources distantes}
Afin d'accéder à des ressources non accessibles en REST, nous avons dû mettre en place des interfaces intermédiaires en PHP. Ces interfaces ayant toutes des fonctions communes, nous avons choisi de créer un framework, en PHP également. Dans ce framework, nous communiquons avec les ressources au moyen d'appel cURL. Nous faisons donc des requêtes GET, éventuellement POST si requis, à chaque ressource. Le fait d'avoir centralisé le code nous permet également de structurer les appels pour respecter l'architecture REST. Toutefois les ressources n'utilisent pas toutes les mêmes conventions et les coups ne sont pas tous donnés sous la même forme. C'est pourquoi on trouve un ou plusieurs parser dans chaque interface intermédiaire. Ces parser permettent de formater les réponses des ressources. Comme nous avions besoin de transmettre peu d'informations, nous avons choisi de transmettre les réponses au format JSON, qui est peu verbeux. Ainsi, le serveur reçoit toutes les réponses dans un format unique.

\subsection{Réprésentation des ressources côté serveur}
Nous avons rapidement déterminé trois types de ressources : les bases de données d'ouvertures, de fermeture et les moteurs d'échec.
Ces trois types de ressources ne nous renvoient pas les mêmes informations. Par exemple, les bases de données d'ouvertures nous renvoient des probabilités de gagner et de perdre ainsi que le nombre de fois que le coup proposé a été joué. Les moteurs d'échec nous renvoient, eux, la profondeur de calcul dans leur arbre de décision ainsi que le score associés à chaque coups.
Nous avons donc contruit nos classes Java sur ce modèle.
\FigureEPS{h,t,b,p}{15cm}{./resources-uml.eps}
{Diagramme UML des ressources côté serveur}   
{fig:diagramme-uml}

\subsection{Base de données SQLite}
Pour chaque ressource, seulement quelques informations doivent être enregistrées telles que l'URL, le nom ou la confiance dans la ressource (cf \label{TODO}). Toutes les ressources, quel que soit leur type, sont enregistrées dans la table Resources. Les utilisateurs du serveur central peuvent aussi créer des parties avec des informations associées concernant le format des réponses. Nous avons donc pour cela besoin d'une seconde table Games. Enfin, les coups proposés par les ressources et sélectionnés par le programme doivent aussi être stockés (cf \label{TODO}). Ces coups s'incrivent dans une partie et sont donc liés à la fois à Resources et à Games. Nous avons donc besoin d'une dernière table Moves.

\FigureEPS{h,t,b,p}{15cm}{./bdd-modele-conceptuel.eps}
{Modèle entité-association de la base de données}   
{fig:modele-bdd}

Pour réaliser cette base de données nous avons choisi d'utiliser le moteur de bases de données SQLite. En effet, ce dernier s'adapte particulièrement à de petites bases de données comme dans notre cas puisqu'il ne suit pas le schéma habituel serveur-client. Les informations sont stockées dans un seul fichier et les accès sont très rapides.

Pour permettre à l'utilisateur de configurer simplement le système nous avons réalisé une interface graphique qui permet essentiellement d'ajouter, d'éditer ou de supprimer les ressources de la base de données. L'interface est réalisée avec la bibliothèque pour Java open-source et multiplateforme, SWT. Elle permet aussi de configurer le système, les pondérations (cf \label{TODO}) et de lancer le serveur central.

\subsection{Utilisation des ressources}
Au démarrage, le serveur central commence par vérifier la disponibilité des ressources. Seulement les ressources qui répondent à cette première requête et qui possèdent une version compatible sont gardées pour la suite.
A chaque appel du serveur central par le client, toutes les ressources sont interrogées pour obtenir une liste de suggestions de coups associés à la position de l'échiquier envoyée. Les ressources répondent ensuite avec un document JSON contenant tous les coups et leurs informations associées. Ce document est convertit en une liste d'objets Java MoveSuggestion (OpeningSuggestion pour les bases de données d'ouverture, etc.).
Les requêtes vers chaque ressources ainsi que la conversion en objets Java sont effectués en parallèle avec l'utilisation de threads.

\subsection{Interface RESTful du serveur central}
Pour effectuer les appels vers les ressources et surtout pour créer l'interface RESTful de notre serveur central nous avons choisi d'utiliser Jersey. Ce framework implémente l'interface de programmation Java \textit{Java API for RESTful Web Services} (JAX-RS) qui permet de créer des services web avec une architecture REST. 
[TODO: Interface Jersey : les requêtes HTTP requises.]

\subsection{Listeners du serveur central}
Nous avons créé trois listeners pour que le serveur central puisse les notifier de tous les évènements qui ont lieu. Le premier listener est avertit de tous les accès qui sont fait au serveur depuis les clients. Le second est notifié lors des accès à la base de données ainsi que lors des exceptions levées. Le dernier listener est appelé pour tous les évènements liés aux ressources, à la fois lorsqu'on les interroge et lorsqu'elles nous répondent.
Cette façon de faire permettra à la personne qui reprendra notre code de développer une interface graphique plus complète que celle que nous avons fait en respectant le patron Modèle-Vue-Contrôleur.


\section{Classement des suggestions de coups}

	Les ressources seules ne permettent pas de choisir directement qeul coup renvoyer au client. En effet, nous devons renvoyer un unique coup (considéré comme étant le meilleur) au client, mais les ressources interrogées nous en conseillent généralement plusieurs.
De ce fait, nous avons donc créé un système permettant de renvoyer le meilleur coup (ou du moins considéré comme tel) au client, en tenant compte des informations renvoyées par les ressources et en intégrant les parties précédemment jouées.

\subsection{Calcul d'un score}
Comme nous l'avons vu au point (TODO), il existe différents types de ressources nous communiquant différant types d'informations.
Cependant, toutes les ressources nous renvoient au moins un coup ainsi que plusieurs informations sur ce coup (la probabilité de gagner et le nombre de fois que le coup a été joué pour les bases d'ouvertures et la profondeur de recherche ainsi que le score attribué au coup pour les bots).

Partant du fait que nous avions pour chaque coups des informations justifiant son choix, nous avons donc décidé de calculer notre propre score associé à ce coup. Ainsi nous réutilisons les informations données par les ressources pour faire notre propre classement des meilleurs coups à jouer (le score renvoyé par les bots ne sera pas le score associé à ce coup, mais simplement une information).
Notre première idée a donc été de sommer les différentes informations afin d'obtenir le score associé. Cependant, toutes les informations n'ont pas le même poids. En effet, par exemple, on peut penser que le score associé par un bot est plus ou moins important par rapport à la profondeur de recherche. Ces différentes pondérations (\(a_{k}\)) sont choisies par l'utilisateur via la GUI. Ainsi, c'est lui qui détermine quelle information privilégier.

Nous avons donc \(Score(coup_{i})_{ressource_{j}}=\sum_{k=1}^na_{k}*f_{k}(x_{k})\) avec \(x_{k}\) la kième information donnée par la ressource sur le \(coup_{i}\) et \(f_{k}\) la fonction de traitement associée à l'information \(x_{k}\) (Voir section suivante pour la définition de \(f_{k}\) ).

Le score calculé précédemment est valable pour un coup proposé par une ressource. Généralement, chaque coup est proposé par plusieurs ressources. Pour obtenir le score total d'un coup, nous avons simplement effectué une somme pondérée des scores (sur les ressources) associé à ce coup. Les pondérations sont liées au fait que l'on fait plus ou moins confiance à chaque ressource. Par exemple, une base de données d'ouverture contenant les parties des plus grands maîtres d'échecs sera plus digne de confiance qu'une base contenant des parties de tournois amateurs.

Nous avons donc la formule suivante :\\ \(Score(coup_{i})=\sum_{k=1}^mT_{k}*Score(coup_{i})_{ressource_{k}}\) avec \(T_{k}\) la confiance accordée à la ressource k.

Ensuite, une fois ces scores calculés pour chaque coup, nous choisissons le coup ayant le score maximal. Ce coup est considéré comme étant le meilleur et est renvoyé au client.

\subsection{Statistiques}
Comme nous l'avons vu précédemment, les informations subissent des traitements (les fonctions \(f_{k}\)) avant d'être agrégées (via la somme). Ces traitements visent essentiellement à rendre comparable les différentes informations obtenues. En effet celles-ci se situent généralement dans des échelles différentes (une probabilité est entre 0 et 1 alors que le nombre de coup joué est potentiellement très élevé). Pour pouvoir mettre les informations à la même échelle nous centrons puis nous réduisons les variables \(x_{k}\) à l'aide des fonctions f associées.

Nous avons donc :\\ \(f_{k}(x_{k})=\frac{x_{k}-\bar{x_{k}}}{\vee(x_{k})}\).

Afin d'obtenir ces statistiques, nous avons donc créé une classe qui s'occupe de gérer et de recalculer après chaque coup les statistiques liées aux différentes informations.

\subsection{Evolution des pondérations}
Le système décrit précédemment permet de bien prendre en compte la diversité des informations ainsi que l'hétérogénéité des ressources mais il reste encore figé. Pour rendre dynamique notre système, nous avons donc fait un système permettant de recalculer à chaque fin de partie la confiance que nous avons dans chaque ressource.

Le principe de l'évolution de la confiance est basé sur un système de récompense. Si nous gagnons la partie, toutes les ressources nous ayant proposés au moins un coup joué lors de la partie seront récompensées positivement. Si nous perdons, elle le seront négativement et en cas de match nul, le système n'évolue pas. De plus, la récompense est proportionnelle à la confiance qu'avait la ressource dans le coup proposé. Plus elle est confiante, plus sa récompense augmente.

Ainsi, nous avons donc un système qui permet d'utiliser les parties passées (via les statistiques et via la confiance dans les ressources) et les différentes informations communiquées par les ressources pour déterminer le meilleur coup à jouer.
Ce système peut néanmoins être améliorer, notamment pour intégrer une notion de ressemblance entre les ressources. En effet, si deux ressources identiques ou se basant sur des données identiques sont appelées (notre système les considère comme différentes), il additionnera les scores associés aux coups proposés par ces ressources, sans s'apercevoir qu'elles sont en fait très proches. Le principe serait donc de calculer une "distance" entre les différentes ressources afin d'atténuer une ressource si une autre ressource "proche" a déjà été prise en compte.


\section{Conclusion} 
 



\end{document}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
