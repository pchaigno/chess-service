%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%     STYLE POUR LES EXPOSES TECHNIQUES 
%         3e année INSA de Rennes
%
%             NE PAS MODIFIER
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\documentclass[a4paper,11pt]{article}

\usepackage{exptech}       % Fichier (./exptech.sty) contenant les styles pour 
                           % l'expose technique (ne pas le modifier)
\usepackage{url}

%\linespread{1,6}          % Pour une version destinée à un relecteur,
                           % décommenter cette commande (double interligne) 
                           
% UTILISEZ SPELL (correcteur orthographique) à accès simplifié depuis XEmacs

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\title{ \textbf{Distributed Chess Service - Guide technique} }
\markright{Distributed Chess Service - Guide technique} 
                           % Pour avoir le titre de l'expose sur chaque page

\author{Paul \textsc{Chaignon}, Thomas \textsc{François}, \\
        Damien \textsc{Le Guen}, Clément \textsc{Gautrais}, \\
				Benoit \textsc{Travers} \\
        \\
        Encadrants : Loïc \textsc{Hélouët}, Yann \textsc{Ricquebourg}}

\date{}                    % Ne pas modifier
 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\begin{document}
\maketitle{}

{\em Ce guide décrit l'organisation technique du projet. Vous y trouverez une description technique des différents modules de notre système. Ce rapport ne décrit donc pas le fonctionnement global du sytème mais porte sur la réalisation technique (au sens des technologies et architectures mises en place) du projet}.

\subsection*{Contexte}
Notre système s'organise en trois entités (cf. figure \ref{fig:schema-systeme}). Tout d'abord, nous avons les ressources externes. Ces ressources nous donnent une liste de coups à jouer dans une situation précise de jeu d'échecs. Ces ressources nous envoient également différentes informations sur ces coups. Il existe trois types de ressources : des bases de données d'ouvertures pour le début de partie, des bots (robots) pour le milieu de partie et des bases de données de fermetures pour la fin de partie.

Tout l'intelligence de notre système réside dans la seconde entité. Cette entité est un serveur qui va utiliser les ressources afin de déterminer le meilleur coup à jouer. Une fois ce coup déterminé, il va le renvoyer à la dernière entité, des clients (jeux d'échecs classiques).
\FigureEPS{h,t,b,p}{11cm}{./ArchitectureSimple.eps}
{Schéma général du système}
{fig:schema-systeme}

\section{Framework PHP}
\label{frameworkPHP}
Le framework PHP permet d'ajouter rapidement une interface entre le serveur central et une nouvelle ressource en ligne.
Il est organisé en trois grandes parties, une pour chaque type de ressources (bases de données d'ouvertures, bases de données de fermetures et moteurs d'échecs pour le milieu de partie).

Il contient à la fois la structure REST, la gestion de version et les appels à la ressource en ligne.
Ce dernier point se fait en utilisant la librairie PHP cURL.

Le numéro de version contient aussi un caractère indiquant si la ressource retourne des notations SAN ou LAN (respectivement 's' ou 'l').
Le framework détecte le type de requête HTTP qui doit être effectué à partir de l'URL donnée.
Si elle contient \textit{\$url\_fen\$} alors la requête doit être GET, sinon elle doit être POST.
Dans le cas d'une requête GET, ce paramètre dans l'URL sera remplacé par le FEN.

Les résultats provenant de la ressource distante sont convertis en un document JSON à l'aide de la fonction de parsing fournie par l'utilisateur.
Pour faire appel à cette fonction, le framework utilise la fonction PHP \textit{call\_user\_func}.
Cette dernière permet d'appeler une fonction donnée sous la forme d'une chaîne de caractères en lui passant des arguments.

La structure REST est adaptée en fonction de la ressource distante. Par exemple, si elle ne renvoie pas de coups d'ouverture ou si l'utilisateur ne désire par les utiliser, le framework ne disposera pas d'un répertoire \textit{openings} dans sa structure.

Enfin, le framework s'occupe aussi d'adapter le FEN suivant les demandes de la ressource en ligne. En effet, certaines ressources requièrent des FEN sous une forme réduite, d'autres sous une forme longue.


\section{Ressources et MoveSuggestions}
\label{ressources_movesuggestion}
Une fois les ressources en état de communiquer avec le serveur central, il est bien entendu nécessaire que ce dernier soit au courant de leur existence afin de pouvoir les interroger.
C'est le rôle de la classe \textit{ResourcesManager} de gérer la liste des ressources accessibles.
En accédant à une base de données externe listant toutes ces ressources, elle peut ensuite pour chacune d'entre elles les représenter à l'aide d'une classe dérivant de la classe abstraite \textit{Resource} en fonction de leur type : \textit{OpeningsDatabase}, \textit{EndingsDatabase} ou \textit{Bot}.

Il est à noter que l'utilisation d'une base de données s'est également révélée nécessaire dans une deuxième partie du serveur central.
En plus de la table SQLite {\tt Resources}, il existe ainsi deux tables {\tt Games} et {\tt Moves} exploitées par la classe \textit{GamesManager}
et qui enregistrent respectivement chaque partie en cours sur le serveur et chaque coup joué.
Ainsi, en plus d'obtenir des informations sur le nombre de parties jouées et leur déroulement,
il est possible d'établir des statistiques précises sur les ressources choisies par le serveur pour donner le meilleur coup.
Au-dessus de \textit{ResourcesManager} et \textit{GamesManager}, la classe abstraite \textit{DatabaseManager} unifie l'utilisation
de ces bases de données SQLite et peut permettre d'ajouter simplement l'accès à une autre table SQLite (cf. figure \ref{fig:uml-database-manager}).

\FigureEPS{h,t,b,p}{16cm}{./uml-database-manager.eps}
{Diagramme UML des gestionnaires de base de données}   
{fig:uml-database-manager}

Lors de la réception d'une requête, chaque ressource va être interrogée une à une.
Dès l'arrivée d'une réponse, celle-ci sera stockée dans une dérivée de la classe \textit{MoveSuggestion}
(à nouveau en fonction du type de la ressource : OpeningsSuggestion, EndingsSuggestion ou BotSuggestion)
accompagnée de toutes les informations qui lui sont associées, telles que son score, sa probabilité de gagner ou de faire match nul.
Ce sont ces données qui serviront en fin de partie à obtenir des statistiques sur la performance des ressources.


\section{Requêtes entrantes RESTful}
Afin d'orchestrer les différents appels entre chaque partie, le projet utilise le framework Grizzly, basé sur une architecture de type RESTful.
Avoir une architecture RESTful permet de mieux exploiter le protocole HTTP.
Les objets ne se manipulent pas seulement avec les méthodes GET et POST, mais aussi avec PUT et DELETE.
De plus, chaque objet est associé à un URL.
Un objet est ainsi manipulable grâce à son URL auquel on effectue des appels avec les méthodes HTTP.
    
Dans notre cas, le serveur central est déployé sur le serveur Grizzly par la classe \textit{CentralServerResourceDeployer}.
La classe \textit{CentralServerResource} est ensuite chargée de réceptionner les requêtes.
Elle contient le c\oe{}ur de l'architecture REST.
Elle capte les requêtes envoyées à l'URI \textit{rest/} et les traite en fonction du type.
Si la requête est de type POST, elle crée une nouvelle partie.
Si c'est un GET, elle lance le processus de mise à jour de suggestion de coups et de sélection du meilleur coup grâce au FEN fourni dans l'URL et renvoie le meilleur coup.
Enfin, dans le cas d'une requête de type DELETE, elle fait les appels de suppression de partie et de récompense.
Des requêtes de type OPTIONS sont également réceptionnées.
Ces requêtes sont inhérentes au script AJAX utilisé par les clients.
Elles servent à déterminer les autorisations données par le serveur.


\section{Listeners}
Le serveur central utilise trois \textit{listeners}. Il appelle les méthodes de ces interfaces dès qu'un évènement quelconque se produit.
Par exemple, si un évènement en lien avec la base de données comme l'ajout ou la suppression d'une ressource se produit, les méthodes correspondantes du \textit{listener} \textit{DatabaseListener} seront appelées (voir figure \ref{fig:uml-listener-database}).
De la même façon, si le serveur central contacte une ressource distante ou reçoit une réponse, le \textit{listener} \textit{ResourceListener} en sera notifié (cf. figure \ref{fig:uml-listeners}).
Enfin, pour tous les évènements liés à l'interface RESTful du serveur central, c'est l'interface \textit{CentralServerListener} qui en sera notifiée (cf. figure \ref{fig:uml-listeners}).

Pour chaque listener, une classe \textit{Adapter} correspondante permet de n'implémenter que certaines méthodes selon les besoins.

\FigureEPS{h,t,b,p}{9cm}{./uml-listener-database.eps}
{Diagramme UML du listener DatabaseListener}   
{fig:uml-listener-database}

\FigureEPS{h,t,b,p}{14cm}{./uml-listeners.eps}
{Diagramme UML des listeners}   
{fig:uml-listeners}

\section{Central Server}
Le serveur central est (comme l'indique son nom) l'élément central de notre service web (cf. figure \ref{fig:schema-centralserver}). En effet, c'est lui qui va être appelé par l'interface REST (celle que le client appelle) pour déterminer le meilleur coup. 
\FigureEPS{h,t,b,p}{11cm}{./SchemaCentralServer.eps}
{Schéma de fonctionnement du serveur central}   
{fig:schema-centralserver}
Ce premier appel est précédé de l'instanciation du serveur central par cette même ressource. Lors de l'instanciation, le serveur central va récupérer les différentes ressources présentes dans la table \textit{Resources} de la base de données spécifiée (dans le fichier conf.properties) au lancement du serveur Grizzly.
Une fois le serveur central instancié, la classe \textit{CentralServerResource} peut demander au serveur central quel coup jouer. Pour cela, la \textit{CentralServerResource} doit lui envoyer au moins la FEN, donnée par le client.
Avec cette FEN, le serveur central va demander aux différentes ressources actives de proposer une liste de coups (avec des informations sur ces coups (cf. section \ref{ressources_movesuggestion})) à jouer dans cette situation de jeu.
Ensuite, grâce aux informations que les ressources lui donnent, le serveur central va déterminer quel est le meilleur coup (cf. section \ref{calcul-coup}) à jouer.
Avant de renvoyer ce meilleur coup, le serveur central va mettre à jour la partie (mise à jour de la FEN courante et ajout des coups proposés dans la table \textit{Moves}) ainsi que les statistiques sur les coups.

\section{Calcul du meilleur coup}
\label{calcul-coup}
Le calcul du meilleur coup constitue, avec les appels aux ressources, le principal contenu du serveur central.
Ce calcul est effectué en plusieurs étapes.
Tout d'abord, le serveur central va demander à chaque ressource (instance de classe dérivée de la classe \textit{Resource})
de mettre à jour la liste de coups qu'elle propose.
Pour cela, la ressource va effectuer une requête GET vers son URL (cf. figure\ref{fig:schema-centralserver}).
Cette requête GET va lui permettre de récupérer les coups que la ressource distante (accessible via l'interface PHP associée) lui propose, au format JSON (cf. partie \ref{frameworkPHP}).
Ce JSON va ensuite être analysé syntaxiquement et les suggestions de coups (instances de classes dérivées de \textit{MoveSuggestion}) créés vont former la liste de coups de la ressource.
En plus de stocker les informations renvoyées par les ressources externes dans les suggestions de coups, on calcule un score pour chaque suggestion.
Ce score est calculé en prenant en compte les informations de la ressources ainsi que des statistiques (accessibles via \textit{StatsManager}) des parties précédentes (cf. rapport pour les formules).
Une fois que toutes les ressources ont mis à jour leur liste de coups, le serveur central va calculer un score associé à chaque coup, prenant en compte les listes de coups de toutes les ressources (cf. rapport pour les formules).
Une fois ces scores calculés, le coup qui a le score le plus élevé est renvoyé au client.
Après avoir déterminé le meilleur coup, les statistiques sur les suggestions de coups sont mises à jour grâce à \textit{StatsManager}.


\section{Évolution des confiances des ressources}
Comme précisé dans le rapport, nous attribuons une certaine confiance à chaque ressource afin de pondérer son influence en fonction de la confiance que nous lui accordons.
Le principe de confiance est semblable à un système de récompense.
Si une ressource nous permet de gagner une partie, elle est récompensée positivement (la confiance que nous lui accordons augmente);
à l'inverse, si elle nous a conseillé lors d'une défaite, elle est récompensée négativement.
Seules les ressources nous ayant proposé au moins un coup que nous avons joué sont récompensées.
Cependant, chaque ressource propose généralement plusieurs coups pour une unique situation.
Il faut donc pondérer la récompense en fonction de la confiance que la ressource apporte dans le coup que nous avons choisi de jouer.
Ainsi, si le score (celui que nous calculons) associé à un coup est maximum pour la ressource, on considèrera que la ressource a confiance en ce coup.
A l'inverse, si le coup a un score faible par rapport au score des autres coups que la ressource propose, nous considèrerons que la ressource a peu confiance en ce coup.
Toutes les confiances des coups d'une partie sont stockées dans la table \textit{Moves}.
A la fin d'une partie, chaque ressource est récompensée proportionnellement à la somme des confiances de tous les coups qu'elle a proposés et que nous avons joués durant cette partie.


\section{Gestion des notations d'échecs}
Aux échecs, les représentations numériques du plateau et des coups sont normalisées.
Ainsi, il existe une notation pour le plateau appelée FEN.
Pour les coups, la notation algébrique est utilisée.
Elle spécifie la case de départ et d'arrivée dans sa version longue et la pièce utilisée et la case d'arrivée dans sa version courte.
Le fait que cette notation ait deux formats nous a posé certains problèmes de compatibilité.
En effet, certaines ressources nous renvoyaient des coups en notation algébrique longue (LAN) et d'autres en notation algébrique courte (SAN).
De plus, les clients graphiques exigent pour certains des coups au format LAN et d'autres au format SAN.
Nous avons donc dû écrire un analyseur syntaxique afin de pouvoir convertir tous les coups au même format.
Cet analyseur est basé sur un déjà existant en JavaScript.
Ce code JavaScript a été convertit en Java et il a été corrigé pour gérer certaines subtilités des échecs (en passant, pat, etc.).
Cet analyseur est contenu dans le package parser.
Étant donné que certaines ressources ne nous renvoie pas toujours des coups en notation algébrique (cela est rare mais néanmoins possible), les différentes méthodes de la classe \textit{ChessParser} effectuant des traitements sur des FEN (conversion de SAN en LAN et vice versa, vérification du en passant et de la mise en échec) peuvent lancer des exceptions (\textit{IncorrectFENException} et \textit{IncorrectAlgebraicNotationException}) (voir figure \ref{fig:uml-parser}).
\FigureEPS{h,t,b,p}{5cm}{./Parser.eps}
{Diagramme UML de la classe ChessParser}   
{fig:uml-parser}


\end{document}
